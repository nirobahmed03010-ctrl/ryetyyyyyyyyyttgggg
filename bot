import logging
import os
from pathlib import Path

from telegram import Update, ReactionTypeEmoji, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    MessageHandler,
    CallbackQueryHandler,
    filters,
    ContextTypes,
)

import yt_dlp

BOT_TOKEN = "8572728429:AAGbA418OuCvgfs1rl46t9UO1vFmrGMaigk"

DOWNLOAD_DIR = Path("downloads")
DOWNLOAD_DIR.mkdir(exist_ok=True)

MAX_FILE_SIZE = 48 * 1024 * 1024

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def handle_link(update: Update, context: ContextTypes.DEFAULT_TYPE):
    url = update.message.text.strip()
    if not url.startswith(('http://', 'https://')):
        return

    try:
        await context.bot.set_message_reaction(
            chat_id=update.effective_chat.id,
            message_id=update.message.message_id,
            reaction=[ReactionTypeEmoji(emoji="ðŸ‘€")],
        )
    except:
        pass

    if "youtube.com" in url or "youtu.be" in url:
        await show_quality_buttons(update, context, url)
    else:
        await download_and_send(update, context, url, None)


async def show_quality_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE, url: str):
    opts = {'quiet': True, 'listformats': True}
    with yt_dlp.YoutubeDL(opts) as ydl:
        info = ydl.extract_info(url, download=False)

    if not isinstance(info, dict) or 'formats' not in info:
        await download_and_send(update, context, url, None)
        return

    formats = info.get('formats', [])
    buttons = []
    seen = set()
    for f in formats:
        h = f.get('height')
        if h and h >= 144 and h not in seen:
            seen.add(h)
            buttons.append(InlineKeyboardButton(f"{h}p", callback_data=f"qual_{url}_{h}"))

    if not buttons:
        await download_and_send(update, context, url, None)
        return

    keyboard = [buttons[i:i+3] for i in range(0, len(buttons), 3)]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text("Select quality:", reply_markup=reply_markup)


async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    data = query.data
    if not data.startswith("qual_"):
        return

    _, url, height_str = data.split("_", 2)
    height = int(height_str)

    await query.edit_message_text(f"Downloading {height}p...")
    await download_and_send(query, context, url, height)


async def download_and_send(update_or_query, context: ContextTypes.DEFAULT_TYPE, url: str, height: int = None):
    opts = {
        'quiet': True,
        'continuedl': True,
        'retries': 5,
        'fragment_retries': 10,
        'noplaylist': True,
        'geo_bypass': True,
        'outtmpl': str(DOWNLOAD_DIR / '%(id)s.%(ext)s'),
        # Speed optimizations
        'format_sort': ['res', 'size', 'codec:avc1'],  # Prefer smaller files + h264
        'format_sort_force': True,
    }

    if height:
        opts['format'] = f'best[height<={height}][ext=mp4]/best[ext=mp4][height<={height}]/best[ext=mp4]/best'
    else:
        opts['format'] = 'best[ext=mp4][vcodec^=avc1]/best[ext=mp4]/best'

    try:
        with yt_dlp.YoutubeDL(opts) as ydl:
            info = ydl.extract_info(url, download=True)

        files = list(DOWNLOAD_DIR.glob("*.*"))
        if not files:
            await send_text(update_or_query, context, "File not found")
            return

        file_path = max(files, key=lambda p: p.stat().st_mtime)
        size = file_path.stat().st_size

        if size > MAX_FILE_SIZE:
            await send_text(update_or_query, context, "File too large (>50MB)")
            file_path.unlink()
            return

        await context.bot.send_video(
            chat_id=update_or_query.effective_chat.id if hasattr(update_or_query, 'effective_chat') else update_or_query.message.chat_id,
            video=open(file_path, "rb"),
            caption=f"Downloaded from:\n{url}",
            supports_streaming=True
        )

        file_path.unlink()

    except Exception as e:
        logger.exception("Download failed")
        err = str(e)[:150]
        await send_text(update_or_query, context, f"Error: {err}")


async def send_text(update_or_query, context, text):
    if hasattr(update_or_query, 'edit_message_text'):
        await update_or_query.edit_message_text(text)
    elif hasattr(update_or_query, 'message'):
        await update_or_query.message.reply_text(text)
    else:
        await context.bot.send_message(chat_id=update_or_query.effective_chat.id, text=text)


def main():
    app = Application.builder().token(BOT_TOKEN).build()
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_link))
    app.add_handler(CallbackQueryHandler(button_callback))
    app.run_polling(drop_pending_updates=True)


if __name__ == "__main__":
    main()
